/******************************
 *
 * Author: Cristian Tapus
 * History:
 *   Dec 22, 2000 - comments and updates added by Cristian Tapus
 *   Nov 20, 2000 - Dejan added some features to the existing functions
 *   Sept 22, 2000 - comments added and debug moded added
 *   July 9, 2000 - first version
 *   July 15, 2000 - comments and update added by Cristian Tapus
 *   Various fixes and additions by Ananta Tiwari (2004-2010)
 *******************************/


/***
 * include other user written headers
 ***/
#include <fcntl.h>
#include "hclient.h"
#include <netinet/in.h>
#include <strings.h>
#include <sys/time.h>
#include <signal.h>


/*
 * global variables
 */

// the purpose of this static variable is to define the debug mode
// when this value is set to 1, different values might be printed for
// debuginng purposes. However, the information that is outputed might
// not make sens (except for the author! :)
static int debug_mode=0;


// the client socket that will support the TCP connection to the server
int hclient_socket=-1;

// id that identifies an application (used for migration)
int hclient_id = -1;

// a global variable that has enables/disables the use of signals for
// getting the information from the server. For more information about
// this variable please consult the Programmer's Guide.
int huse_signals;


// this list of VarDef keeps track of all the variables registered by the
// application to the server. This information is only kept on the client
// side for now, as no use of it was needed on the server side as of now...
// For information about the VarDef class, please consult hmesgs.(ch)
list<VarDef> reg_vars;

// the timestamp used by the simplex minimization method to decide
// whether the performance reflects the changes of the parameters
unsigned long int hclient_timestamp = 0;


/***
 * prototypes of side functions
 ***/
void process_update(HUpdateMessage *m);


/***
  * function definitions
 ***/

/**
 *
 * returns the local socket used for connection to server
 *
 **/
int get_local_sock() {
     printf("Local Socket Number: %d \n", hclient_socket);
    return hclient_socket;
}

int get_hclient_id() {
    return hclient_id;
}


// the purpose of these double definition is the use of different
// calls for the same function. I will clean this in the next version.
int hget_local_sock() {
    return hclient_socket;
}

int set_local_sock(int sock_port) {
	hclient_socket=sock_port;
}

/***
 *
 * Exit and send a mesage to stderr
 *
 ***/
void hc_exit(char *errmesg){
    perror(errmesg);
    harmony_end();
    exit(1);
}


// this is an internal definition class
// that serves the purposes of finding objects in a list. (STL stuff)
// this way we find a Variable in the list of registered variables
// by its name
class findVarbyName {
  private:
    char *n;
  public:
    findVarbyName(char *vN){
        n=(char *)malloc(strlen(vN));
        strcpy(n,vN);
    }

    bool operator () (VarDef& Var) {
        //printf("comparing: %s with %s :: the result is: %d \n", n, Var.getName(),!strcmp(n, Var.getName()));
        return (!strcmp(n, Var.getName()));
    }
};

void (*app_sigio_handler)(int);

/*****
 *
 * this is the definition of the sigio handler. This function gets called
 * if the user decided to use this mechanism to get information from the
 * server (rather then polling the server when it needs the information!)
 *
 *****/
void hsigio_handler(int s) {
    // the purpose of this set of file descriptors is to see if the SIGIO
    // was generated by information received on the harmony communication
    // socket
    fd_set modif_sock;

    //  if (debug_mode)
    //fprintf(stderr, "***** Got SIGIO %d !\n",s);

    while(1){
      again:

        // initialize the set of modified file descriptor to check for
        // harmony socket only
        FD_ZERO(&modif_sock);
        FD_SET(get_local_sock(),&modif_sock);

        // set tv for polling
        struct timeval tv =  {0, 0};
        int res;

        if ((res = select(get_local_sock()+1,&modif_sock, NULL, NULL, &tv)) < 0) {
            if (errno = EINTR)
                goto again;
            perror("ERROR in SELECT");
            hc_exit("Error in select");
        }

        if (!res)
            break;

        // if the harmony communication socket is one of the modified
        // sockets, then we have a packet from the server
        if (FD_ISSET(get_local_sock(),&modif_sock)) {
            // check the message from the server

            // we can read data from the socket. define for this a message
            // we know that from the server we only get update messages
            HUpdateMessage *m;

            m = (HUpdateMessage *) receive_message(get_local_sock());

            // print the content of the message if in debug mode
            if (debug_mode)
                m->print();

            process_update(m);
            delete m;

#ifdef NOTDEF
            // BUGGG: There ARE more variables updated at a time!
            // we know that only one variable is updated at a time by SIGIO
            // we will find the variable
            // *** above comment added by Dejan
            // *** below response added by Cristian
            // this is not necessarily a BUG. By the way the server currently
            // sends the variables, we expect only one variable at a time
            // this is to be updated in a later version
            list<VarDef>::iterator VarIterator =
                find_if(reg_vars.begin(), reg_vars.end(),findVarbyName(m->get_var(0)->getName()));

            // if the variable was not found just print an error message and
            // continue. Maybe the server messed things up and data was sent to
            // the bad client. Who knows what might have happened!
            if (VarIterator==reg_vars.end()) {
                //fprintf(stderr, "(sigio handler)Harmony error: Variable not registerd: %s!\n",
                m->get_var(0)->getName());
            return;
        }
        else {
            // the variable was found and its value needs to be updated

            if (debug_mode)
                VarIterator->print();

            // update shadow value for variable
            // we only update the shadow value of the variable because we want
            // the user to be the only one to decide when the actual value of the
            // variable to get changed. There are only certain points in the
            // program where these changes might be reflected
            switch (VarIterator->getType()) {
                case VAR_INT:
                    VarIterator->setShadow(*(int *)m->get_var(0)->getPointer());
                    break;
                case VAR_STR:
                    VarIterator->setShadow((char *)m->get_var(0)->getPointer());
                    break;
            }

            if (debug_mode)
                VarIterator->print();
        }
        // free the space that was previously allocated
        delete m;
#endif
    }
    else
        app_sigio_handler(s);
}
}


/*********
 *        block_sigio(), unblock_sigio()
 * Description: (un)blocks sigio signals
 * Used from:   routines that send messages asynchronously to the server
 *
 ***********/

int hsigio_blocked = FALSE;
void block_sigio() {
#if     defined(SOLARIS) || defined(__linux)
    sigset_t    set;
    sigemptyset(&set);
    sigaddset(&set, SIGIO);
    sigaddset(&set, SIGALRM);
    sigprocmask(SIG_BLOCK, &set, NULL);
#else
    sigblock(sigmask(SIGIO));
#endif  /*SOLARIS*/
    hsigio_blocked = TRUE;
};

void unblock_sigio() {
#ifdef DEBUG_SIGIO
    if (!hsigio_blocked) {
        //fprintf(stderr, "WARNING: Improper state or use of unblock_sigio\n");
    }
#endif  /*DEBUG_SIGIO*/
    hsigio_blocked = FALSE;
#ifdef  SOLARIS
    sigset_t    set;
    sigemptyset(&set);
    sigprocmask(SIG_SETMASK, &set, NULL);
#else
    sigsetmask(0);
#endif  /*SOLARIS*/
};


/*
 * this variables are used for migration
 * we save the server and port of the server in case we have to migrate
 *
 */
char harmony_host[256];
int harmony_port;

/*
 * When a program registers with the harmony server it uses this function
 *
 * Params:
 *  use_sigs (int) - the client will use signals if the value is 1
 *                   the client will use polling if the value is 0
 *                   the client will use sort of a polling if value is 2
 *  relocated (int)- this checks if the client has been migrating lately
 *                   the use of this variable is not very clear yet, but
 * 			Dejan insisted on having it.
 *  sport (int)    - the port of the server
 *  shost (char *) - the host of the server
 *
 * The return value is the socket that we will further use for the connection
 */
//void harmony_startup(int use_sigs) {

void harmony_startup_port(int use_sigs, int sport)
{
    harmony_startup(use_sigs, 0, sport, NULL);
}



void harmony_startup(int use_sigs, int relocated, int sport, char *shost) {
//void harmony_startup(int relocated = 0, int sport = 0, char *shost = NULL) {
//    int use_sigs = 0;
    struct sockaddr_in address;
    struct hostent *hostaddr = NULL;
    char *hostname;
    HRegistMessage *mesg;

    char temps[BUFFER_SIZE];

    int fileflags;

    //fprintf(stderr, "hs:%d\n", __LINE__);

    /* set the flag that tells if we use signals */
    huse_signals = use_sigs;

    /* create socket */
    if ((hclient_socket=socket(AF_INET,SOCK_STREAM,0))<0) {
        hc_exit("Could not create socket!");
    }

    /* connect to server */
    address.sin_family = AF_INET;

    // look for the HARMONY_S_PORT environment variable
    // to set the port of connection to the machine where the harmony
    // server is running

    if (sport == 0){
        if (getenv("HARMONY_S_PORT")==NULL)
            hc_exit("HARMONY_S_PORT variable not set!");
        sport = atoi(getenv("HARMONY_S_PORT"));
    }
    address.sin_port=htons(sport);

    //look for the HARMONY_S_HOST environment variable
    // to set the host where the harmony server resides
    if (shost == NULL){
        if (getenv("HARMONY_S_HOST")==NULL)
            hc_exit("HARMONY_S_HOST variable not set!");
        shost=getenv("HARMONY_S_HOST");
    }
    hostname = shost;

    if ((hostaddr=gethostbyname(hostname)) == NULL)
        hc_exit("Host not found!");

    /* save server hostname and port if necessary to migrate */
    strcpy(harmony_host, hostname);
    harmony_port = sport;

    /* set up the host address we will connect to */
#ifdef Linux
    inet_aton(inet_ntop(hostaddr->h_addrtype,hostaddr->h_addr,temps,sizeof(temps)), &address.sin_addr);
#else
    bcopy((char *)hostaddr->h_addr, (char *)&address.sin_addr, hostaddr->h_length);
#endif
    int optVal = 1;
    int ret = setsockopt(hclient_socket, SOL_SOCKET, SO_REUSEADDR, (char *) &optVal, sizeof(int));
    if (ret) {
        perror("setsockopt");
        hc_exit("<setsockopt>fd_create");
    }

    // try to connect to the server
    if (connect(hclient_socket,(struct sockaddr *)&address, sizeof(address))<0)
        hc_exit("Connection failed!");

    /* send the registration message */
    mesg = new HRegistMessage(HMESG_CLIENT_REG, huse_signals);

    if (relocated){
        assert(hclient_id > 0);
        mesg->set_id(hclient_id);
    }
    send_message(mesg,hclient_socket);

    delete mesg;

    /* wait for confirmation */

    mesg = (HRegistMessage *)receive_message(hclient_socket);
    hclient_id = mesg->get_id();
    assert(hclient_id > 0);
    delete mesg;

    if (huse_signals) {
        // install the SIGIO signal handler
        // and set which file descriptor to produce the SIGIO
#undef DONT_SAVE_OLD_HANDLER
#ifdef DONT_SAVE_OLD_HANDLER
        signal(SIGIO, hsigio_handler);
#else
        struct sigaction    ha_act, app_act;

        ha_act.sa_handler = hsigio_handler;
        sigemptyset(&ha_act.sa_mask);
        sigaddset(&ha_act.sa_mask, SIGALRM);
#if defined(__sun) && ! defined(__SVR4)
        ha_act.sa_flags = 0;
#else
        ha_act.sa_flags = SA_RESTART;
#endif
        if (sigaction(SIGIO, &ha_act, &app_act)){
            hc_exit("segv sigaction problem");
        }

        // save app handler to call it if SIGIO is not for Harmony
        app_sigio_handler = app_act.sa_handler;

#endif
        if (fcntl(hclient_socket, F_SETOWN, getpid()) < 0) {
            hc_exit("fcntl F_SETOWN");
        }

        if (fileflags = fcntl(hclient_socket, F_GETFL ) == -1) {
            hc_exit("fcntl F_GETFL");
        }

#ifdef LINUX
        // this does not work on SOLARIS
        if (fcntl(hclient_socket, F_SETFL, fileflags | FASYNC) == -1)
            hc_exit("fcntl F_SETFL, FASYNC");
#endif

    }

    //fprintf(stderr, "handler installed\n");
}


/*
 * When a program announces the server that it will end it calls this function
 */
void harmony_end(){

    //fprintf(stderr, "he:%d\n", __LINE__);

    HRegistMessage *m = new HRegistMessage(HMESG_CLIENT_UNREG,0);

    // send the unregister message to the server
    send_message(m,hclient_socket);


    //printf("Exit message sent!\n");

    delete m;

    /* wait for server confirmation */

    m =(HRegistMessage *) receive_message(hclient_socket);

    //printf("Message received!?!\n");
    //m->print();

    delete m;

    //printf("Close socket!\n");

    // close the actual connection
    close(hclient_socket);

}


/*
 * Inform the Harmony server of the bundles and requirements of the application
 */
void harmony_application_setup(char *description){


    HDescrMessage *mesg=new HDescrMessage(HMESG_APP_DESCR,description,strlen(description));

    send_message(mesg, hclient_socket);

    delete mesg;


    /* wait for confirmation */
    HMessage *m;
    m=receive_message(hclient_socket);

    if (m->get_type()!=HMESG_CONFIRM) {
        // something went wrong on the server side !
        //fprintf(stderr," Unexpected message type: %d\n",m->get_type());
        delete m;
        hc_exit("Application description is not correct!\n");
    }

    delete m;
}



/***
 * this version of the function reads the description from a given filename
 * and passes it as a string to the above defined function
 ***/
void harmony_application_setup_file(char *fname) {

    struct stat *statb=(struct stat *)malloc(sizeof(struct stat));
    int fd;
    char *d;

    //fprintf(stderr, "hasf:%d ; filename:%s\n", __LINE__, fname);


    // check the file stat
    if (stat(fname, statb)<0)
        hc_exit("Error get file stat!");

    // open the file
    if ((fd=open(fname, 0))<0)
        hc_exit("Error open file!");

    // alloc the data
    d=(char *)malloc(statb->st_size+1);

    // read the data
    if (read(fd,d,statb->st_size)<0)
        hc_exit("Error reading description!");

    d[statb->st_size]='\0';

    // free file stat
    free(statb);

    // close the file
    if (close(fd)<0)
        hc_exit("Error closing file!");

    // send description to server
    harmony_application_setup(d);
}


/*
 * Bind a local variable with a harmony bundle
 *
 * Params:
 * 	appName (char *) - the name of the application
 *   	bundleName (char *) - the name of the bundle we want to bind
 *	type (int) the type of the variable we want to bind: INT, STR
 *	localonly (int) - used by Dejan. The use is not very clear to me
 *			  I guess he doesn't want the variable to have the
 *				name defined as the others have, but rather
 *				take the name of the bundle
 */

void * harmony_add_variable(char *appName, char *bundleName, int type, int localonly){
//void * harmony_add_variable(char *appName, char *bundleName, int type, int localonly = 0){
    if (appName == NULL)
        appName = "client";
    //fprintf(stderr, "hav: %s %s %d\n", appName, bundleName, localonly);

    if (localonly) {
        VarDef v(bundleName, type);
        v.alloc();

        reg_vars.push_back(v);

        // return the pointer of the variable
        void *r = reg_vars.rbegin()->getPointer();
        //fprintf(stderr, "hav out %x\n", r);
        return r;
    }

    // block_sigio();
    // the variable
    VarDef v;
    // the variable name as known by TCL
    char varN[MAX_VAR_NAME];

    if (debug_mode)
        fprintf(stderr, "appName:%s ; bundleName:%s\n",appName, bundleName);

    // create the name of the variable as described in the Tcl code that
    // accompanies Harmony
    sprintf(varN,"%s_%d_bundle_%s",appName,hclient_id,bundleName);

    if (debug_mode)
        fprintf(stderr, "Variable Tcl Name: %s ; Type %d ; Strlen:%d \n",varN, type, strlen(varN));

    // send variable registration message
    HDescrMessage *m=new HDescrMessage(HMESG_VAR_DESCR, bundleName, strlen(bundleName));
    send_message(m,get_local_sock());
    delete m;


    // wait for confirmation
    // the confirmation message also contains the initial value of the
    // variable
    HMessage *mesg;
    mesg=receive_message(get_local_sock());


    if (debug_mode)
        mesg->print();

    if (mesg->get_type()==HMESG_FAIL) {
        /* failed to register variable with server */
        fprintf(stderr, "Failed to register variable %s from application %s \n",bundleName, appName);
        delete mesg;
        //unblock_sigio();
        hc_exit("Please check variable!");
    }

    /*
      if the flag is registered, expect for a NONE message.

      still to be implemented.

    */




    // add the variable to the registered variable list
    v=*((HUpdateMessage *)mesg)->get_var(0);

    //fprintf(stderr, "v.getName()=%s\n", v.getName());
    delete mesg;

    reg_vars.push_back(v);
    //unblock_sigio();

    // return the pointer of the variable
    return reg_vars.rbegin()->getPointer();

}


// this is another helper class
// that is designed for finding variables in the registered variables list
// by the address of the value of the variable
class findVarbyPointer {
  private:
    void *p;
  public:
    findVarbyPointer(void *vp){
        p=vp;
    }

    bool operator () (VarDef& Var) {
        return p==Var.getPointer();
    }
};



/*
 * Send to the server the value of a bound variable
 */
void harmony_set_variable(void *variable){
    //fprintf(stderr, "set variable\n");

    // get the variable associated with the pointer
    list<VarDef>::iterator VarIterator =
        find_if(reg_vars.begin(), reg_vars.end(),findVarbyPointer(variable));

    // if variable was not found just print an error and continue
    if (VarIterator==reg_vars.end()) {
        //fprintf(stderr, "(set_variable)Harmony error: Variable not registered: %s\n", ((VarDef*)variable)->getName());
        return;
    }
    else {
        //block_sigio();
        // send request message
        HUpdateMessage *m=new HUpdateMessage(HMESG_VAR_SET, 0);

        switch (VarIterator->getType()) {
            case VAR_INT:
                VarIterator->setShadow(*(int *)VarIterator->getPointer());
                break;
            case VAR_STR:
                VarIterator->setShadow((char *)VarIterator->getPointer());
                break;
        }
        m->set_var(*VarIterator);

        if (debug_mode)
            m->print();

        send_message(m,get_local_sock());
        delete m;

        // wait for the answer from the harmony server
        HMessage *mesg=(HMessage *)receive_message(get_local_sock());

        if (mesg->get_type()==HMESG_FAIL) {
            /* could not set variable value */
            delete mesg;
            hc_exit("Failed to set variable value!");
        } else if (mesg->get_type()==HMESG_VAR_REQ) {
            /* received an update */
            process_update((HUpdateMessage*)mesg);
        }

        delete mesg;
        //unblock_sigio();
    }
}

/*****
      Name:        Process an update message
      Description: Set shadow values of updated variables to received values
      Called from: sigio_handler and harmony_set_variable
*****/
void process_update(HUpdateMessage *m) {
    //fprintf(stderr, "num vars in update: %d\n", m->get_nr_vars());
    for (int i = 0; i < m->get_nr_vars(); i++) {
        VarDef *v = m->get_var(i);
        //fprintf(stderr, "varName: %s\n", v->getName());

        list<VarDef>::iterator VarIterator =
            find_if(reg_vars.begin(), reg_vars.end(),findVarbyName(v->getName()));

        // if the variable was not found just print an error message and
        // continue. Maybe the server messed things up and data was sent to
        // the bad client. Who knows what might have happened!
        if (VarIterator==reg_vars.end()) {
            //fprintf(stderr, "Harmony error: Variable not registerd: %s!\n", v->getName());
        } else {
            switch (v->getType()) {
                case VAR_INT:
                    VarIterator->setShadow(*(int*)v->getPointer());
                    break;
                case VAR_STR:
                    VarIterator->setShadow((char*)v->getPointer());
                    //fprintf(stderr, "new val: %s [%s] shadow [%s]\n", v->getName(),
                    //(char*)(VarIterator->getPointer()),
                    //        VarIterator->getShadow());
                    break;
            }
        }
        //fprintf(stderr, "up\n");
    }
}

/*
 * Update bound variables on server'side.
 */
void harmony_set_all(){
    //fprintf(stderr, "hsa:%d\n", __LINE__);

    //block_sigio();
    // go through the entire list of registered variables and create a
    // message containing all these variables and their values

    list<VarDef>::iterator VarIterator;

    HUpdateMessage *m=new HUpdateMessage(HMESG_VAR_SET, 0);

    for (VarIterator=reg_vars.begin();VarIterator!=reg_vars.end(); VarIterator++) {
        switch (VarIterator->getType()) {
            case VAR_INT:
                VarIterator->setShadow(*(int *)VarIterator->getPointer());
                break;
            case VAR_STR:
                VarIterator->setShadow((char *)VarIterator->getPointer());
                break;
        }
        m->set_var(*VarIterator);
    }

    // send the message to the server
    send_message(m,get_local_sock());
    delete m;

    // wait for the confirmation
    HMessage *mesg=receive_message(get_local_sock());

    if (mesg->get_type()==HMESG_FAIL) {
        /* could not set variable value */
        delete mesg;
        hc_exit("Failed to set variables!");
    } else if (mesg->get_type()==HMESG_VAR_REQ) {
        /* received an update */
        process_update((HUpdateMessage*)mesg);
    }


    delete mesg;
    //unblock_sigio();
}


/*
 * Get the value of a bound variable
 */
void *  harmony_request_variable(char *variable){

    //fprintf(stderr, "hrv:%d\n", __LINE__);

    // lookup variable by the pointer in the registered variables list

    int  dummy = -100000;

    int *ip = &dummy;

    list<VarDef>::iterator VarIterator =
        find_if(reg_vars.begin(), reg_vars.end(),findVarbyName(variable));

    // if variable is not found just print an error message and continue
    if (VarIterator==reg_vars.end()) {
        fprintf(stderr, "(request_var)Harmony: Variable not registered: %s\n", ((VarDef*)variable)->getName());
        return (int*) ip;
    }
    else {
        // here we have to differentiate between using and not using signals
        // if signals are used then we just have to copy the shadow value of the
        // variable into the actual value
        // otherwise we have to send a message to the server, requesting
        // for the value of the variable.

        if (huse_signals) {
            // we use signals so values have been updated!
            // just copy the shadow into the value

            switch (VarIterator->getType()) {
                case VAR_INT:
                    VarIterator->setValue(*(int *)VarIterator->getShadow());
                    break;
                case VAR_STR:
                    VarIterator->setValue((char *)VarIterator->getShadow());
                    break;
            }

            return (int *) ip;
        }

        // signals are not used

        // send request message
        HUpdateMessage *m=new HUpdateMessage(HMESG_VAR_REQ, 0);
        m->set_var(*VarIterator);


        if (debug_mode)
            m->print();

        send_message(m,get_local_sock());
        delete m;

        // wait for answer
        HMessage *mesg = receive_message(get_local_sock());

        if (mesg->get_type()==HMESG_FAIL) {
            // the server could not return the value of the variable
            delete mesg;
            //fprintf(stderr, "Harmony error: Server could not return value of variable!\n");
            return ip;
        }

        m=(HUpdateMessage *)mesg;
         hclient_timestamp = m->get_timestamp();
        if (debug_mode)
            m->print();

        // update the value
        switch (VarIterator->getType()) {
            case VAR_INT:
                VarIterator->setValue(*(int *)m->get_var(0)->getPointer());
                return (int *)m->get_var(0)->getPointer();
                break;
            case VAR_STR:
                VarIterator->setValue((char *)m->get_var(0)->getPointer());
                return (char *)m->get_var(0)->getPointer();
                break;
        }

        //printf("Check the original value of the variable: %d \n", (int *)m->get_var(0)->getOrig());

        delete m;
    }

}

/*
  Check if the new code is ready
*/

int harmony_code_generation_complete(int iteration)
{
    return code_generation_complete(iteration);
}


/*
 for compatability. Will have to get rid of this in the future.
*/
int code_generation_complete(int iteration)
{
     // define the VarDef

    char* variable = "code_completion";

    //printf("received code completion request \n");
    VarDef *var = new VarDef(variable, VAR_INT);

    // define a message

    HUpdateMessage *m=new HUpdateMessage(HMESG_CODE_COMPLETION, 0);

    var->setValue(iteration);
    m->set_timestamp(hclient_timestamp);
    m->set_var(*var);

    //if (debug_mode)
    //    m->print();

    send_message(m,get_local_sock());

    //delete var;
    delete m;

    // wait for answer
    HMessage *mesg = receive_message(get_local_sock());

    if (mesg->get_type()==HMESG_FAIL) {
        // the server could not return the value of the variable
        printf("The Server failed to return the respose to code generation!!\n");
        delete mesg;
        /* this needs to be checked thoroughly. */
        return -1;
    }

    m=(HUpdateMessage *)mesg;

    //m->print();
    //if (debug_mode)
    //    m->print();
    VarDef *v = m->get_var(0);
    int result =  *(int *)m->get_var(0)->getPointer();
    //printf("The result for CODE GENERATION is : %d \n", result);

    delete m;
    return result;
}



/*
 * Get the current value of all the bound variables
 *
 * Params:
 *   pull (int)
 */
void harmony_request_all(int pull){
//void harmony_request_all(int pull = 0){

    // here we also have to differentiate between use of signals and
    // no signals
    //fprintf(stderr, "hra:%d\n", __LINE__);

    list<VarDef>::iterator VarIterator = reg_vars.begin();
    //  //fprintf(stderr, "ALL\n");
    if (huse_signals & !pull) {
        // we use signals, so we just have to copy the shadow to the actual value
        for (;VarIterator!=reg_vars.end();VarIterator++) {
            //      //fprintf(stderr, "A %s\n", VarIterator->getName());
            switch (VarIterator->getType()) {
                case VAR_INT:
                    VarIterator->setValue(*(int *)VarIterator->getShadow());
                    break;
                case VAR_STR:
                    VarIterator->setValue((char *)VarIterator->getShadow());
                    break;
            }
        }
        return;
    }

    // if signals are not used
    // send request message
    HUpdateMessage *m=new HUpdateMessage(HMESG_VAR_REQ, 0);

    for (;VarIterator!=reg_vars.end();VarIterator++)
        m->set_var(*VarIterator);

    if (debug_mode)
        m->print();

    send_message(m,get_local_sock());
    delete m;


    HMessage *mesg = receive_message(get_local_sock());

    if (mesg->get_type()==HMESG_FAIL) {
        // the server could not return the value of the variable
        delete mesg;
        //fprintf(stderr, "Harmony error: Server could not return value of variable!\n");
        return;
    }

    m=(HUpdateMessage *)mesg;

    // first update the timestamp
    hclient_timestamp = m->get_timestamp();

    printf("updates timestamp from the server for this client: %d \n", hclient_timestamp);



    if (debug_mode)
        m->print();

    // update variables from the content of the message
    int i;

    for (VarIterator=reg_vars.begin(),i=0;VarIterator!=reg_vars.end();VarIterator++,i++) {
        switch (VarIterator->getType()) {
            case VAR_INT:
                VarIterator->setValue(*(int *)m->get_var(i)->getPointer());
                break;
            case VAR_STR:
                VarIterator->setValue((char *)m->get_var(i)->getPointer());
                break;
        }
    }
    delete m;
}



/*
 * Send the performance function result to the harmony server
 */

void harmony_performance_update(int value){

    // create a new variable
    VarDef *v = new VarDef("obsGoodness",VAR_INT);

    v->setValue(value);

    HUpdateMessage *m=new HUpdateMessage(HMESG_PERF_UPDT, 0);

    // first set the timestamp to be sent to the server
    m->set_timestamp(hclient_timestamp);

    printf("hclient_timestamp: %d \n", hclient_timestamp);

    m->set_var(*v);

    //m->set_flag(0);

    if (debug_mode)
    {
        m->print();
    }


    //printf("Sending a performance update message \n");
    send_message(m,get_local_sock());
    delete m;

    // I am not sure that you should actually wait for confirmation
    // for now we will not wait for reply.

    // wait for the answer from the harmony server

    HMessage *mesg=(HMessage *)receive_message(get_local_sock());

    if (mesg->get_type()==HMESG_FAIL) {
        // could not send performance function
        delete mesg;
        hc_exit("Failed to send performance function! \n");
    }

    delete mesg;
}

void harmony_performance_update(double value){

    // create a new variable
    VarDef *v = new VarDef("obsGoodness",VAR_STR);
    printf("check point 2 \n");
    char c_value[256];

    

    sprintf(c_value, "%.15g", value);

    
    printf("check point 2 %s \n", c_value);
    
    v->setValue(c_value);

    HUpdateMessage *m=new HUpdateMessage(HMESG_PERF_UPDT, 0);

    // first set the timestamp to be sent to the server
    m->set_timestamp(hclient_timestamp);

    printf("hclient_timestamp: %d \n", hclient_timestamp);

    m->set_var(*v);

    //m->set_flag(0);

    if (debug_mode)
    {
        m->print();
    }


    //printf("Sending a performance update message \n");
    send_message(m,get_local_sock());
    delete m;
    HMessage *mesg=(HMessage *)receive_message(get_local_sock());

    if (mesg->get_type()==HMESG_FAIL) {
        // could not send performance function
        delete mesg;
        hc_exit("Failed to send performance function! \n");
    }

    delete mesg;


}

void harmony_performance_update_with_conf(int value, char* conf){


    //printf("Harmony_performance_update function: %d \n", value);

    // create a new variable
    VarDef *v = new VarDef(conf,VAR_INT);

    printf("Created the vardef ... \n");

    v->setValue(value);

    HUpdateMessage *m=new HUpdateMessage(HMESG_WITH_CONF, 0);

    // first set the timestamp to be sent to the server
    m->set_timestamp(hclient_timestamp);

    //printf("hclient_timestamp: %d \n", hclient_timestamp);

    m->set_var(*v);

    //m->set_flag(0);

    //m->print();

    if (debug_mode)
    {
        m->print();
    }


    printf("Sending a performance update message \n");
    send_message(m,get_local_sock());
    delete m;
    HMessage *mesg=(HMessage *)receive_message(get_local_sock());

    //mesg->print();

    if (mesg->get_type()==HMESG_FAIL) {
        // could not send performance function
        delete mesg;
        hc_exit("Failed to send performance function! \n");
    }

    delete mesg;
    //printf("Exiting performance update function \n");
}


/*
 * Get the value of a probe variable
 * for now, this is sort of a temporary solution. the probe variables are
 * not registered in the tcl backend only.
 * A new message type has been defined to take care of a separate type
 * of Update Message.
 */
int harmony_request_probe(char *variable, int type){

    // define the VarDef

    VarDef *var = new VarDef(variable, VAR_INT);

    // define a message

    HUpdateMessage *m=new HUpdateMessage(HMESG_PROBE_REQ, 0);

    var->setValue(0);
    m->set_timestamp(hclient_timestamp);
    m->set_var(*var);

    //if (debug_mode)
    //    m->print();

    send_message(m,get_local_sock());

    delete m;

    // wait for answer
    HMessage *mesg = receive_message(get_local_sock());

    if (mesg->get_type()==HMESG_FAIL) {
        // the server could not return the value of the variable
        printf("The Server failed to return the value of the probe variable!!\n");
        delete mesg;
        /* this needs to be checked thoroughly. */
        return -1;
    }

    m=(HUpdateMessage *)mesg;

    if (debug_mode)
        m->print();
    VarDef *v = m->get_var(0);
    int result =  *(int *)m->get_var(0)->getPointer();
    delete m;

    return result;
}
/*
 * get the value of any tcl backend variable - for ex. next_iteration
 *  this handles int variables
 */
int * harmony_request_tcl_variable_int(char *variable){

    // define the VarDef

    VarDef *var = new VarDef(variable, VAR_INT);
    //printf("received a tcl variable request \n");
    // define a message

    HUpdateMessage *m=new HUpdateMessage(HMESG_TCLVAR_REQ, 0);

    var->setValue(1000);
    m->set_timestamp(hclient_timestamp);
    m->set_var(*var);

    //if (debug_mode)
    //    m->print();

    send_message(m,get_local_sock());

    //delete var;
    delete m;

    // wait for answer
    HMessage *mesg = receive_message(get_local_sock());
    //printf("received a message back \n");
    if (mesg->get_type()==HMESG_FAIL) {
        // the server could not return the value of the variable
        printf("The Server failed to return the value of the tcl variable!!\n");
        delete mesg;
        /* this needs to be checked thoroughly. */
        hc_exit("error in tcl vairable retrieval. Is the variable defined in the tcl backend? \n");
    }

    m=(HUpdateMessage *)mesg;

    //if (debug_mode)
    //    m->print();
    VarDef *v = m->get_var(0);
    int* result =  (int *)m->get_var(0)->getPointer();
    //printf("Result from TCL BACKEND : %d \n", *result);

    //delete m;
    return result;
}

/*
 * get the value of any tcl backend variable - for ex. next_iteration
 * string variables
 */
char * harmony_request_tcl_variable_char(char *variable){

    // define the VarDef

    VarDef *var = new VarDef(variable, VAR_STR);

    // define a message

    HUpdateMessage *m=new HUpdateMessage(HMESG_TCLVAR_REQ, 0);

    var->setValue("dummy");
    m->set_timestamp(hclient_timestamp);
    m->set_var(*var);

    //if (debug_mode)
    //    m->print();

    send_message(m,get_local_sock());

    //delete var;
    delete m;

    // wait for answer
    HMessage *mesg = receive_message(get_local_sock());

    if (mesg->get_type()==HMESG_FAIL) {
        // the server could not return the value of the variable
        printf("The Server failed to return the value of the tcl variable!!\n");
        delete mesg;
        /* this needs to be checked thoroughly. */
    }

    m=(HUpdateMessage *)mesg;

    VarDef *v = m->get_var(0);
    char* result =  (char *)m->get_var(0)->getPointer();
    delete m;

    return result;
}

int harmony_request_tcl_variable_2(char *variable, int type){

    // define the VarDef

    VarDef *var = new VarDef(variable, VAR_INT);

    // define a message

    HUpdateMessage *m=new HUpdateMessage(HMESG_TCLVAR_REQ_2, 0);

    var->setValue(1000);
    m->set_timestamp(hclient_timestamp);
    m->set_var(*var);

    //if (debug_mode)
    //    m->print();

    send_message(m,get_local_sock());

    //delete var;
    delete m;

    // wait for answer
    HMessage *mesg = receive_message(get_local_sock());

    if (mesg->get_type()==HMESG_FAIL) {
        // the server could not return the value of the variable
        printf("The Server failed to return the value of the probe variable!!\n");
        delete mesg;
        /* this needs to be checked thoroughly. */
        return -1;
    }

    m=(HUpdateMessage *)mesg;

    //if (debug_mode)
    //    m->print();
    VarDef *v = m->get_var(0);
    int result =  *(int *)m->get_var(0)->getPointer();
    delete m;


    return result;
}


void * harmony_request_tcl_variable(char* variable, int type) 
{
    void * return_val;
    switch(type)
    {
        case VAR_INT:
            return_val=(void*)harmony_request_tcl_variable_int(variable);
            break;
        case VAR_STR:
            return_val=(void*) harmony_request_tcl_variable_char(variable);
            break;
    }
    return return_val;
}

/*
 * ask for the performance value of the previously evaluated
 * configuration. Mostly used within an offline tuning scenario to avoid
 * duplicate evaluation of configurations. The server uses a simple map to
 * keep track of previously evaluated configurations.
*/
double harmony_database_lookup(){

    // define the VarDef
    //printf("Vardef Constructor: \n");
    VarDef *var = new VarDef("database", VAR_STR);
    //printf("Vardef Constructor: ...  done \n");
    // define a message
    HUpdateMessage *m=new HUpdateMessage(HMESG_DATABASE, 0);

    var->setValue("100");
    m->set_timestamp(hclient_timestamp);
    m->set_var(*var);

    if (debug_mode)
        m->print();

    send_message(m,get_local_sock());

    // wait for answer
    HMessage *mesg = receive_message(get_local_sock());

    if (mesg->get_type()==HMESG_FAIL) {
        // the server could not return the value of the variable
        printf("The Server failed to return perf from database... \n");
        delete mesg;
        /* this needs to be checked thoroughly. */
        return -1;
    }

    m=(HUpdateMessage *)mesg;

    //m->print();

    if (debug_mode)
        m->print();
    VarDef *v = m->get_var(0);
    
    char* perf_dbl=(char*)(m->get_var(0)->getPointer());

    printf("performance is: %s \n", perf_dbl);

    double result=atof(perf_dbl);

    // double result =  *(int *)m->get_var(0)->getPointer();

    // delete v;
    //delete m;
    //delete mesg;

    return result;
}

/* this takes care of the updating for probe variables.
 */
void harmony_set_probe_perf(char *variable, int value){

    //fprintf(stderr, "set probe variable\n");

    // define the VarDef

    VarDef *var = new VarDef(variable, VAR_INT);

    // define a message

    HUpdateMessage *m=new HUpdateMessage(HMESG_PROBE_SET, 0);

    var->setValue(value);
    var->setType(VAR_INT);
    m->set_timestamp(hclient_timestamp);
    m->set_var(*var);

    //if (debug_mode)
    //    m->print();

    send_message(m,get_local_sock());

    delete m;

    return;

}

/*
 * Ask for the best configuration that we have seen so far during this
 * tuning run. The configuration is returned as a char pointer. The
 * parameters are separated by spaces. The application needs to parse this.
*/
char* harmony_get_best_configuration()
{
    return (char*)harmony_request_tcl_variable("best_coord_so_far",1);
}
