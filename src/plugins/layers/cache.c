/*
 * Copyright 2003-2016 Jeffrey K. Hollingsworth
 *
 * This file is part of Active Harmony.
 *
 * Active Harmony is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Active Harmony is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Active Harmony.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * \page cache Point Caching/Replay layer (cache.so)
 *
 * This processing layer records point/performance pairs in a local
 * cache as they are reported by clients.  If the strategy later
 * generates any points that exist in the cache, this layer will
 * return the associated recorded performance immediately.  Note that
 * any outer layers (include the Harmony server and client) will not
 * be notified upon cache hit.
 *
 * The cache may optionally be initialized by a log file generated
 * from the [Point Logger](\ref logger).
 */

#include "session-core.h"
#include "hspace.h"
#include "hpoint.h"
#include "hperf.h"
#include "hutil.h"
#include "hcfg.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

/*
 * Name used to identify this plugin layer.
 * All Harmony plugin layers must define this variable.
 */
const char harmony_layer_name[] = "cache";

/*
 * Configuration variables used in this plugin.
 * These will automatically be registered by session-core upon load.
 */
hcfg_info_t plugin_keyinfo[] = {
    { CFGKEY_CACHE_FILE, NULL, "Log file generated by the Point Logger." },
    { NULL }
};

typedef struct {
    hpoint_t point;
    hperf_t perf;
} cache_t;

typedef struct {
    hpoint_t point;
    unsigned int count;     // times visited = nth matching point to get
    unsigned int total_num; // how many times this point appears in data
} visited_t;

/*
 * Structure to hold all data needed by an individual search instance.
 *
 * To support multiple parallel search sessions, no global variables
 * should be defined or used in this plug-in layer.
 */
typedef struct data {
    hrange_t*  dim;
    cache_t*   cache;
    int        cache_len, cache_cap;
    visited_t* visited;
    int        visited_len, visited_cap;
    int        skip;
    int        i_cnt;
    int        o_cnt;
    char*      buf;
    int        buflen;
} data_t;

static data_t* data;

/*
 * Internal helper function prototypes.
 */
static data_t*    alloc_data(void);
static int        find_max_strlen(void);
static int        load_logger_file(const char* logger);
static int        safe_scanstr(FILE* fd, int bounds_idx, const char** match);
static visited_t* find_visited(const hpoint_t* a);

/* Initialize global variables.  Also loads data into cache from a log
 * file if configuration variable CACHE_FILE is defined.
 */
int cache_init(hspace_t* space)
{
    const char* filename;

    if (!data) {
        // One-time search instance initialization.
        data = alloc_data();
        if (!data) {
            session_error("Could not allocate data for Cache layer");
            return -1;
        }
    }

    // Remaining setup needed for every initialization, including
    // re-initialization due to a restarted search.
    //
    data->i_cnt = space->len;
    data->o_cnt = hcfg_int(session_cfg, CFGKEY_PERF_COUNT);
    if (data->o_cnt < 1) {
        session_error("Invalid value for " CFGKEY_PERF_COUNT
                      " configuration key.");
        return -1;
    }
    data->dim = space->dim;

    data->cache = NULL;
    data->cache_len = data->cache_cap = 0;

    data->visited = NULL;
    data->visited_len = data->visited_cap = 0;

    filename = hcfg_get(session_cfg, CFGKEY_CACHE_FILE);
    if (filename) {
        data->buflen = find_max_strlen() + 1;
        data->buf = malloc(data->buflen * sizeof(char));
        if (!data->buf) {
            session_error("Could not allocate memory for string buffer");
            return -1;
        }

        if (load_logger_file(filename) != 0)
            return -1;

        free(data->buf);
    }

    return 0;
}

/*
 * Generate function: look up point in array.
 *
 * Sets status to HFLOW_RETURN with trial's performance set to
 * retrieved value if the point is found.  Otherwise, sets status to
 * HFLOW_ACCEPT (pass point on in plugin workflow).
 */
int cache_generate(hflow_t* flow, htrial_t* trial)
{
    int pt_num;
    visited_t* visited_pt;

    // So the client gets a chance to do something when the search is
    // converged not really part of cache, but gemm example client
    // will never terminate or do anything if this isn't present (it
    // never knows when strat is converged)
    //
    if (strncmp(hcfg_get(session_cfg, CFGKEY_CONVERGED), "1", 1) == 0) {
        return HFLOW_ACCEPT;
    }

    visited_pt = find_visited(&trial->point);

    if (visited_pt != NULL) {
        // wrapping around (i.e. if point occurs twice, and we're
        // coming back for the third time we should give back the
        // first point
        //
        if (visited_pt->total_num > 0 &&
            visited_pt->count > visited_pt->total_num)
        {
            visited_pt->count = visited_pt->count % visited_pt->total_num + 1;
        }
    }

  cache_lookup:
    pt_num = 0;

    // For now, we rely on a linear cache lookup.
    for (int i = 0; i < data->cache_len; ++i) {
        if (hpoint_eq(&trial->point, &data->cache[i].point)) {
            hperf_copy(&trial->perf, &data->cache[i].perf);
            data->skip = 1;
            flow->status = HFLOW_RETURN;
            pt_num++;

            if (visited_pt != NULL) {
                if (pt_num == visited_pt->count || visited_pt->count == 0) {
                    return 0; // Point found, is % nth point listed
                              // (where n = times visited).
                }
            }
            else {
                return 0;     // Point found, never visited.
            }
        }
    }

    if (visited_pt != NULL) {
        // Reached end of data = we know how many times this point appears.
        visited_pt->total_num = pt_num;
        visited_pt->count = visited_pt->count % visited_pt->total_num;
        goto cache_lookup;
    }

    if (!data->skip)
        flow->status = HFLOW_ACCEPT; // Point not found.

    return 0;
}

/*
 * Analyze each trial as it passes through the system.  Add the
 * observed point/performance pair to the cache unless it was a result
 * of a cache hit.
 */
int cache_analyze(hflow_t* flow, htrial_t* trial)
{
    visited_t* visited_pt;

    if (!data->skip) {
        if (data->cache_len == data->cache_cap) {
            if (array_grow(&data->cache, &data->cache_cap,
                           sizeof(*data->cache)) != 0)
            {
                session_error("Could not allocate more memory for cache");
                return -1;
            }
        }

        hpoint_copy(&data->cache[data->cache_len].point, &trial->point);
        hperf_copy(&data->cache[data->cache_len].perf, &trial->perf);
        ++data->cache_len;
    }
    data->skip = 0;

    visited_pt = find_visited(&trial->point);
    // Add to list of visited points.
    if (visited_pt == NULL) {
        if (data->visited_cap == data->visited_len) {
            if (array_grow(&data->visited, &data->visited_cap,
                           sizeof(*data->visited)) != 0)
            {
                session_error("Could not allocate memory for visited array");
                return -1;
            }
        }
        hpoint_copy(&data->visited[data->visited_len].point, &trial->point);

        // Looking for the 2nd occurrence next time we get to generate().
        data->visited[data->visited_len].count = 2;
        ++data->visited_len;
    }
    else {
        // Or update existing visited point info.
        ++visited_pt->count;
    }

    flow->status = HFLOW_ACCEPT;
    return 0;
}

int cache_fini(void)
{
    for (int i = 0; i < data->cache_cap; ++i) {
        hpoint_fini(&data->cache[i].point);
        hperf_fini(&data->cache[i].perf);
    }
    free(data->cache);

    for (int i = 0; i < data->visited_cap; ++i)
        hpoint_fini(&data->visited[i].point);
    free(data->visited);

    free(data);
    data = NULL;
    return 0;
}

/*
 * Internal helper function implementation.
 */
data_t* alloc_data(void)
{
    data_t* retval = calloc(1, sizeof(*retval));
    if (!retval)
        return NULL;

    return retval;
}

/*
 * Search the parameter space for any HVAL_STR dimensions, and return
 * the length of the largest possible string.
 */
int find_max_strlen(void)
{
    int max = 0;

    for (int i = 0; i < data->i_cnt; ++i) {
        if (data->dim[i].type == HVAL_STR) {
            for (int j = 0; j < data->dim[i].bounds.e.len; ++j) {
                int len = strlen(data->dim[i].bounds.e.set[j]) + 1;
                if (max < len)
                    max = len;
            }
        }
    }
    return max;
}

/*
 * Initialize the in-memory cache using a log file generated from the
 * logger layer during a prior tuning session.
 *
 * Note: This function must be kept in sync with the output routines
 *       of the logger layer.
 */
#define SKIP_PATTERN(fp, pattern)                                       \
    if (fscanf(fp, pattern) == EOF) {                                   \
        session_error("Error parsing logger file: Invalid input.");     \
        return -1;                                                      \
    }
int load_logger_file(const char* filename)
{
    char c;
    int i, ret;
    FILE* fp;

    fp = fopen(filename, "r");
    if (!fp) {
        session_error("Could not open log file.");
        return -1;
    }

    while (fscanf(fp, " %c", &c) != EOF) {
        // Skip any line that doesn't start with 'P'.
        if (c != 'P') {
            SKIP_PATTERN(fp, "%*[^\n] ");
            continue;
        }
        SKIP_PATTERN(fp, "oint #%*d: ( ");

        // Prepare a new point in the memory cache.
        if (data->cache_len == data->cache_cap) {
            if (array_grow(&data->cache, &data->cache_cap,
                           sizeof(*data->cache)) != 0)
            {
                session_error("Could not allocate more memory for cache");
                return -1;
            }
        }
        if (hpoint_init(&data->cache[data->cache_len].point, data->i_cnt) != 0)
        {
            session_error("Error allocating memory for point in cache");
            return -1;
        }

        if (hperf_init(&data->cache[data->cache_len].perf, data->o_cnt) != 0)
        {
            session_error("Error allocating memory for performance in cache");
            return -1;
        }

        // Parse point data.
        for (i = 0; i < data->i_cnt; ++i) {
            hval_t* v = &data->cache[data->cache_len].point.term[i];

            if (i > 0) SKIP_PATTERN(fp, " ,");

            v->type = data->dim[i].type;
            switch (data->dim[i].type) {
            case HVAL_INT:  ret = fscanf(fp, "%ld", &v->value.i); break;
            case HVAL_REAL: ret = fscanf(fp, "%*f[%la]", &v->value.r); break;
            case HVAL_STR:  ret = safe_scanstr(fp, i, &v->value.s); break;
            default:
                session_error("Invalid point value type");
                return -1;
            }

            if (ret != 1) {
                session_error("Error parsing point data from logfile");
                return -1;
            }
        }

        // Parse performance data.
        SKIP_PATTERN(fp, " ) => (");
        for (i = 0; i < data->o_cnt; ++i) {
            if (i > 0) SKIP_PATTERN(fp, " ,");
            if (fscanf(fp, " %*f[%la]",
                       &data->cache[data->cache_len].perf.obj[i]) != 1)
            {
                session_error("Error parsing performance data from logfile");
                return -1;
            }
        }

        // Discard the rest of the line after the right parenthesis.
        if (fscanf(fp, " %c%*[^\n]", &c) != 1 || c != ')') {
            session_error("Error parsing point data from logfile");
            return -1;
        }
        ++data->cache_len;
    }
    fclose(fp);
    return 0;
}

/*
 * Parse a double-quoted string value from a file stream.  Static
 * variables buf and buflen must be initialized prior to use.
 *
 * Return values designed to match scanf family.
 */
int safe_scanstr(FILE* fp, int bounds_idx, const char** match)
{
    int i;
    range_enum_t* bounds = &data->dim[bounds_idx].bounds.e;

    SKIP_PATTERN(fp, " \"");
    for (i = 0; i < data->buflen; ++i) {
        int c = fgetc(fp);

        if (c == '\\')
            c = fgetc(fp);
        if (c == '\"' || c == EOF)
            break;

        data->buf[i] = (char)c;
    }
    if (i == data->buflen) {
        session_error("Input HVAL_STR overrun");
        return EOF;
    }
    data->buf[i] = '\0';

    for (i = 0; i < bounds->len; ++i) {
        if (strcmp(data->buf, bounds->set[i]) == 0)
            break;
    }
    if (i == bounds->len) {
        session_error("Invalid HVAL_STR value");
        return 0;
    }

    *match = bounds->set[i];
    return 1;
}

visited_t* find_visited(const hpoint_t* a)
{
    for (int i = 0; i < data->visited_len; ++i) {
        if (hpoint_eq(a, &data->visited[i].point))
            return data->visited + i;
    }
    return NULL;
}
