#
# Copyright 2003-2011 Jeffrey K. Hollingsworth
#
# This file is part of Active Harmony.
#
# Active Harmony is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Active Harmony is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with Active Harmony.  If not, see <http://www.gnu.org/licenses/>.
#

# the performance canvas has some fixed values from now. 
# the layout is the following: 
#  visible width: 500 ; visible height: 200
#  scroll region width: 5000 ; scroll region height: 200
# we are going to compute the place where we place the predicted function threshold
# based on the values used for the observed function. As described in the specs, the
# observed function should provide some min and max values which are not to be 
# crossed by normal execution. However, we understand that this kind of values are
# difficult to be provided in an absolute manner, so our code would not crash if
# the values obtained are outside the given range.

set visible_height 400
set visible_width 500
set scroll_height 400
set scroll_width 500


proc begin_tail_process {filename widget} {
			# There's no provision here for an unreadable $filename.
		set fd [open "|tail -f $filename" r]
		fconfigure $fd -blocking off -buffering line
        #fconfigure $fd -buffering line
        #-blocking no
		fileevent $fd readable "process_one_line $fd $widget"
	}
	
	
	proc handle_command_arguments {} {
		global argc argv
	
		if {1 != $argc} {
			puts "The syntax is 'experiment FILENAME'."
			exit 1
		}
		return [lindex $argv 0]
	}
	
	
	########
	#
	#	process_one_line
	#
	#	Notice that there's no exception-handling ($filename
	#	     becomes unreadable, ...)
	#
	########
	proc process_one_line {fd widget} {
		gets $fd line
			# Put the new tail-ed line at the bottom of
			#     the display.
		$widget insert end "$line\n"
			# Ensure that the last line is visible.
		$widget yview -pickplace end
	}
	
	
	proc setup_display_widget text_widget {
		text $text_widget
		pack $text_widget
	}




proc center_window {w} {
    wm withdraw $w
    update idletasks
    set x [expr [winfo screenwidth $w]/2 - [winfo reqwidth $w]/2 \
	  - [winfo vrootx [winfo parent $w]]]
    set y [expr [winfo screenheight $w]/2 - [winfo reqheight $w]/2 \
	  - [winfo vrooty [winfo parent $w]]]
    wm geom $w +$x+$y
    wm deiconify $w
  }

proc button_test {appName} {
    #deiconify .application_jacobi_3
    #lower .application_jacobi_3
    center_window .application_jacobi_3
    #raise .application_jacobi_3
}

proc drawPerformance_bak {appName} {
    # first check if any of the functions is defined
  upvar #0 ${appName}_predGoodness predG
  upvar #0 ${appName}_obsGoodness obsG

  if {[info exists predG] && [info exists obsG]} {
    #label .application_${appName}.performanceText -width 70 -pady 5 -anchor w -text "Performance function:"     
    #pack .application_${appName}.performanceText

    global ${appName}_obsGoodness(isglobal)
    upvar #0 ${appName}_obsGoodness(isglobal) isglobal

    puts "Drawing performance for $appName : $isglobal"

    if {$isglobal >= 0} {
      checkbutton .application_${appName}.performanceisglobal -text "global" -variable ${appName}_obsGoodness(isglobal) -command "update_perf_isglobal $appName"
      pack .application_${appName}.performanceisglobal -anchor w
    }



   # attributes default: width 250 height 200 scroll region: 0 0 5000 200
    #Scrolled_Canvas .application_${appName}.performance -width 320 -height 200 -scrollregion {0 0 5000 200} -background #E0E088
    # Scrolled_Canvas .application_${appName}.performance -width 200 -height 200 -scrollregion {0 0 5000 1000} -background #F0F8FF
    Scrolled_Canvas .application_${appName}.performance $isglobal -width 200 -height 200 -scrollregion {0 0 0 0} -background #F0F8FF
    pack .application_${appName}.performance

    drawharmonyPredGoodness $appName

    drawharmonyObsGoodness $appName


  }

}

proc button_command { i appName } {
    center_window .application_${appName}_$i
}

proc drawPerformance {appName} {
  # first check if any of the functions is defined
  upvar #0 ${appName}_predGoodness predG
  upvar #0 ${appName}_obsGoodness obsG

  if {[info exists predG] && [info exists obsG]} {
    #label .application_${appName}.performanceText -width 70 -pady 5 -anchor w -text "Performance function:"     
    #pack .application_${appName}.performanceText

    global ${appName}_obsGoodness(isglobal)
    upvar #0 ${appName}_obsGoodness(isglobal) isglobal

    #puts "Drawing performance for $appName : $isglobal"

    if {$isglobal >= 0} {
      checkbutton .application_${appName}.performanceisglobal -text "global" -variable ${appName}_obsGoodness(isglobal) -command "update_perf_isglobal $appName"
      pack .application_${appName}.performanceisglobal -anchor w


    Scrolled_Canvas .application_${appName}.performance $isglobal -width 500 -height 200 -scrollregion {0 0 5000 200} -background #F0F8FF
   # attributes default: width 250 height 200 scroll region: 0 0 5000 200
    #Scrolled_Canvas .application_${appName}.performance -width 320 -height 200 -scrollregion {0 0 5000 200} -background #F0F8FF
    # Scrolled_Canvas .application_${appName}.performance -width 400 -height 400 -scrollregion {0 0 5000 1000} -background #F0F8FF
    #Scrolled_Canvas .application_${appName}.performance -width 400 -height 400 -scrollregion {0 0 400 400} -background #F0F8FF
    pack .application_${appName}.performance -expand true -fill both

    
    drawharmonyPredGoodness $appName

    #drawharmonyObsGoodness $appName
    } else {

        
        frame .application_${appName}.top_panel
        frame .application_${appName}.bottom

        labelframe .application_${appName}.code_server -text "Code Generation Staus" -width 500 -height 200
        labelframe .application_${appName}.local_status -text "Processor Level Status" -width 500 -height 100

        set canvas_returned [Scrolled_Canvas .application_${appName}.performance $isglobal -width 500 -height 200 -scrollregion {0 0 5000 200} -background #F0F8FF]
        text .application_${appName}.tail_text -wrap word -bg #F0F8FF -font "sans 8" -fg black


        pack .application_${appName}.tail_text -in .application_${appName}.code_server -expand true -fill both
        pack .application_${appName}.performance -in .application_${appName}.top_panel -side left  -expand true -fill both
        pack .application_${appName}.code_server -in .application_${appName}.top_panel -side right  -expand true -fill both
        #pack .application_${appName}.local_status -in .application_${appName}.bottom  -side bottom  -expand true -fill both

        ### HARD CODED FOR THE DEMO
        #set npoints 8

        #for {set i 0} {$i<$npoints} {incr i} {
        #    set i_plus_one [expr ($i+1)]
        #    global  ${appName}_${i_plus_one}_label_text
        #    upvar #0 ${appName}_${i_plus_one}_label_text label_text
        #    #puts "${appName}_${i_plus_one}_label_text"
        #    if {![info exists label_text]} {
        #        set label_text " " 
        #    }
        #     button .application_${appName}.b$i -text " Rank $i " -justify left -command "button_command $i_plus_one $appName" -relief sunken -bg #F0F8FF -padx 5 -pady 5
        #     pack .application_${appName}.b$i -in .application_${appName}.local_status -expand true -fill both
        #}
        #pack .application_${appName}.local_status -in .application_${appName}.bottom  -side bottom  -expand true -fill both
        #pack .application_${appName}.top_panel .application_${appName}.bottom -side top  -expand true -fill both
        

        drawharmonyPredGoodness $appName

     
        #begin_tail_process "/hivehomes/tiwari/SC09-demo/code_repository/code_generation.log" .application_${appName}.tail_text
        
    }
    



    ##############  added for SC09 demo ##########


  }
}

proc update_perf_isglobal {appName} {

  upvar #0 ${appName}_obsGoodness(isglobal) isglobal

  #first get the real name of the application without the socket number
  set aName [string range $appName 0 [expr [string last "_" $appName]-1]]
  #puts "aName=$aName"

  global ${aName}_obsGoodness

  if {$isglobal==0} {
        if {[info exists ${aName}_obsGoodness]} {
          global ${aName}_obsGoodness(deplocals)
          upvar #0 ${aName}_obsGoodness(deplocals) deplocals

          set pos [lsearch -exact $deplocals ${appName}_obsGoodness]

          puts "Removing position $pos from $deplocals"

          set ${aName}_obsGoodness(deplocals) [lreplace $deplocals $pos $pos]

          puts "Removed from list: $deplocals"
        } else {
          info globals ADR_obsGoodness
          puts "Global ${aName}_obsGoodness does not exist"
        }
  }  else {
        if {[info exists ${aName}_obsGoodness]} {
          upvar #0 ${aName}_obsGoodness(deplocals) deplocals

          lappend deplocals ${appName}_obsGoodness
          puts "Added to list: $deplocals"

          # here we might have a problem if somebody played with the
          # global and local values independently.
          # one way to protect against this kind of problems is
          # to force all the variables we depend on to become global
          # as well.
          # for now we are not going to implement this
          # this note is just for further improvements, if the need is
          # found for this kind of details.

        } else {
          puts "Global ${aName}_obsGoodness does not exist"
          set $isglobal 0
        }
  }
}



# this function is "imported" from Brent B. Welch
# "Practical Programming in Tcl and Tk"
proc Scrolled_Canvas { c isglobal args } {

        set frametext ""
        if { $isglobal < 0 } {
            set frametext "Global Performance"
        } else {
            set frametext "Local Performance"
        }
        labelframe $c -text $frametext
        eval {canvas $c.canvas \
                -xscrollcommand [list $c.xscroll set] \
                -yscrollcommand [list $c.yscroll set] \
                -highlightthickness 0 \
                -borderwidth 0} $args
        scrollbar $c.xscroll -orient horizontal \
                -command [list $c.canvas xview]
        scrollbar $c.yscroll -orient vertical \
                -command [list $c.canvas yview]
        grid $c.canvas $c.yscroll -sticky news
        grid $c.xscroll -sticky ew
        grid rowconfigure $c 0 -weight 1
        grid columnconfigure $c 0 -weight 1
        return $c.canvas
}

proc canvasyCoord {appName y} {
  upvar #0 ${appName}_obsGoodness(min) omin
  upvar #0 ${appName}_obsGoodness(max) omax
  set step [expr 200.0/($omax-$omin)]

  return [expr ($omax-$y)*$step]
}

proc drawharmonyPredGoodness {appName} {

  upvar #0 ${appName}_predGoodness(min) pmin
  upvar #0 ${appName}_predGoodness(max) pmax
  upvar #0 ${appName}_obsGoodness(min) omin
  upvar #0 ${appName}_obsGoodness(max) omax
  set step [expr 200.0/($omax-$omin)]
#  .application_${appName}.performance.canvas create line 0 [expr 200-($pmin-$omin)*$step] 5000 [expr 200-($pmin-$omin)*$step] -fill red -tag predGmin
#  .application_${appName}.performance.canvas create line 0 [expr ($omax-$pmax)*$step] 5000 [expr ($omax-$pmax)*$step] -fill red -tag predGmax

  .application_${appName}.performance.canvas create line 0 [canvasyCoord $appName $pmin] 5000 [canvasyCoord $appName $pmin] -fill red -tag predGmin
  .application_${appName}.performance.canvas create line 0 [canvasyCoord $appName $pmax] 5000 [canvasyCoord $appName $pmax] -fill red -tag predGmax
  .application_${appName}.performance.canvas create line 0 0 0 5000 -fill darkgreen -tag timeLine

 .application_${appName}.performance.canvas create text 0 [canvasyCoord $appName $pmin] -anchor nw -text "predGoodness(min): $pmin" -fill red -tag {predGmin predGminText}
 .application_${appName}.performance.canvas create text 0 [canvasyCoord $appName $pmax] -anchor sw -text "predGoodness(max): $pmax" -fill red -tag {predGmax predGmaxText}
  .application_${appName}.performance.canvas create text 0 0 -anchor nw -text " time line: " -fill darkgreen -tag {timeLine timeLineText}

  .application_${appName}.performance.canvas bind predGmin <B1-Motion> {predGDrag %W %y predGmin}
  .application_${appName}.performance.canvas bind predGmax <B1-Motion> {predGDrag %W %y predGmax}
  .application_${appName}.performance.canvas bind timeLine <B1-Motion> {timeLineDrag %W %x}

}


proc drawharmonyObsGoodness {appName} {
  global ${appName}_obsGoodness(coordinates)
  upvar #0 ${appName}_obsGoodness(coordinates) coords

#  .application_${appName}.performance.canvas delete obsGoodness

#  .application_${appName}.performance.canvas create line $coords -fill blue -tag obsGoodness

#  puts "Here I have: [lindex $coords [expr [llength $coords]-1]] [lindex $coords end]"
#  puts "Coords: $coords"

  drawCross .application_${appName}.performance.canvas [lindex $coords [expr [llength $coords]-2]] [lindex $coords end]
  
   set perf_multiplier 10000.0
  set npoints 8
    
    global ${appName}_obsGoodness(isglobal)
    upvar #0 ${appName}_obsGoodness(isglobal) isglobal
    #puts "Drawing performance for $appName : $isglobal"

    if {$isglobal < 0} {
        set counter 0
        set best_perf 0
        for {set i 0} {$i<$npoints} {incr i} {
                set i_plus_one [expr ($i+1)]
                #global  ${appName}_${i_plus_one}_label_text
                upvar #0 ${appName}_${i_plus_one}_label_text label_text
                upvar #0 ${appName}_${i_plus_one}_performance perf_int
                set perf $perf_int
                
                if {![info exists label_text]} {
                    set label_text " " 
                }

                if {![info exists perf]} {
                    set perf ""
                } else { 
                    set perf [expr $perf/$perf_multiplier]
                    if { $i == 0 } {
                        set best_perf $perf
                    }
                    if { $best_perf > $perf } {
                        set best_perf $perf
                        set counter $i
                    } 
                }
                   
                .application_${appName}.b$i configure -text " Rank $i $label_text ${perf}s " -bg #F0F8FF
        }

        .application_${appName}.b$counter configure -bg #99FF66
}


}


proc drawCross {win xcoord ycoord} {
  $win create line [expr 2*$xcoord-1] $ycoord [expr 2*$xcoord+2] $ycoord -fill blue -tag obsGoodness
  $win create line [expr 2*$xcoord] [expr $ycoord-1] [expr 2*$xcoord] [expr $ycoord+2] -fill blue -tag obsGoodness
}


proc timeLineDrag {win x} {
  set tempStr [string range $win [expr [string first "_" $win]+1] [string length $win]]
  set appName [string range $tempStr 0 [expr [string first "." $tempStr]-1] ]

  set oldx [lindex [$win coords timeLine] 0]

  set newx [expr $x + 5000*[lindex [$win xview] 0]]

  set dx [expr $newx-$oldx]

  set nx [expr $oldx+$dx]

  if {$nx>0 && $nx<5000} {

    $win move timeLine $dx 0

    $win itemconfigure timeLineText -text " time line: [expr $newx/2]"
  }
}

proc predGDrag {win y what} {


  set tempStr [string range $win [expr [string first "_" $win]+1] [string length $win]]
  set appName [string range $tempStr 0 [expr [string first "." $tempStr]-1] ]

  global ${appName}_predGoodness
  global ${appName}_obsGoodness

  upvar #0 ${appName}_predGoodness(min) pmin
  upvar #0 ${appName}_predGoodness(max) pmax
  upvar #0 ${appName}_obsGoodness(min) omin
  upvar #0 ${appName}_obsGoodness(max) omax

  set step [expr 200.0/($omax-$omin)]

  set newy [expr $y+200*[lindex [$win yview] 0]]

  if {[string match predGmax $what]} {
    set inity [cadr [$win coords predGmax]]
    set oldpmax $pmax
    set pmax [expr $pmax-($newy-$inity)/$step]

    if {$pmax > $omax || $pmax < $pmin} {
      set pmax $oldpmax
    } else {
      $win move predGmax 0 [expr $newy-$inity]
      $win itemconfigure predGmaxText -text  "predGoodness(max): $pmax"
    }
  } else {
    set inity [cadr [$win coords predGmin]]
    set oldpmin $pmin
    set pmin [expr $pmin-($newy-$inity)/$step]

    if {$pmin < $omin || $pmin > $pmax} {
      set pmin $oldpmin
    } else {
      $win move predGmin 0 [expr $newy-$inity]
      $win itemconfigure predGminText -text  "predGoodness(min): $pmin"
    }
  }
}
