/* Generated by libcreater automatically */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <dlfcn.h>
#include "libnb.h"
#include "$1.h"
#define _ALPHA 0  /* 0: only new counts; 1: only old counts */


/* enumeration data type */
$$

enum _decision {_MANUAL,_AUTOMATIC};

/* TODO : fix those enum problem */

/* lib system built-in structure */


/* lib system variables */

	struct $1_method _methodtable[$1_NOMETHOD];

	struct $1_metric _metrictable[$1_NOMETRIC];

	static int _currentmethodid;

        static void * _currentlib;

	static int _decision=_$2;

/* variables generated from src */
$$


/* private functions */


int _$1comp(void *i, void *j) {

if(*($1 *)i<*($1 *)j)
	return 1;
else
	return 0;
}

$1 * _$1updateequa($1 *new, $1 *old) {

	if(old!=NULL)
		*new=($1)((1.0-_ALPHA)*((float)(*new))+_ALPHA*((float)(*old)));

	return new;
}

int _getmethodid(char *name) {

        int i;

        for(i=0;i<$2_NOMETHOD;i++)
                if(strcmp(_methodtable[i].name,name)==0)
                        return i;

        return $2_NO_SUCH_METHOD;
}

char * _getmethodname(int id) {

        return _methodtable[id].name;

}

char * _getmethodlib(int id) {
	
	return _methodtable[id].libfilename;

}

char * _setstring(char *s) {

	char *t;
/*
	int l=strlen(s)+1;
	t=(char *)malloc(l*sizeof(char));
	strcpy(t,s);
	t[l]='\0';
*/
	t=strdup(s);

	return t;
}

char *_findcvt(int srcid, int dstid) {

        return _methodtable[dstid].cvtfunc[srcid].cvtfuncname;



}

int _getmetricid(char *mc) {

        int i;
        for(i=0;i<$2_NOMETRIC;i++)
                if(strcmp(_metrictable[i].name,mc)==0)
                        break;

        if(strcmp(_metrictable[i].name,mc)==0)
                return i;

        return $2_NO_SUCH_METRIC;

}

char * _findest(int md_id, int mc_id) {

        return _methodtable[md_id].mntfunc[mc_id].estfuncname;


}

char * _findcvtest(int src_md_id, int dst_md_id) {

        return _methodtable[dst_md_id].cvtfunc[src_md_id].cvtestfuncname;

}

char * _findmnt(int md_id, int mc_id) {

        return _methodtable[md_id].mntfunc[mc_id].mntfuncname;

}

char * _findfunc(int md_id, int f_id) {

        return _methodtable[md_id].interfacefunc[f_id].funcname;


}

$$


void $1_final(void) {

	dlclose(_currentlib);	

}


/* interface functions */
$$


/* used for manual decision only */
int setmethod(char *md /*method name*/) {


	void (*cvtfrom)();

	int mt=_getmethodid(md);

	if(mt==$1_NO_SUCH_METHOD)
		return $1_NO_SUCH_METHOD;

	/* conversion : change method */
	
	if (_currentmethodid==mt)  /* nothing to transfer */
		return $1_OK;

	//printf("setmethod:%s\n",md);

	dlclose(_currentlib);

	_currentlib=dlopen(_getmethodlib(mt),RTLD_LAZY);

	if(_findcvt(_currentmethodid,mt) != NULL)
		cvtfrom=dlsym(_currentlib,_findcvt(_currentmethodid,mt));



	/*_currentmethodid=mt;*/

	/* conversion cases */

$$

	/*else*/

	_currentmethodid=mt;

	return $1_NO_SUCH_TRANSFORM;

	/*_currentmethodid=mt;
	
	return $1_OK;*/

}


int methodquery(void **table) {


	*table=_methodtable;

	return $1_NOMETHOD;

}
	
int metricquery(void **table) {

	*table=_metrictable;

	return $1_NOMETRIC;
}



int estimate(char *mc ,char *md /* method name: NULL current */, void ** result) {


	void *lib;

	int mt,ms;

$$

	if(md==NULL)  /* use current method */
		mt=_currentmethodid;
	else
		mt=_getmethodid(md);

	ms=_getmetricid(mc);

	lib=dlopen(_getmethodlib(mt),RTLD_LAZY);

$$


	dlclose(lib);

	return $1_NO_SUCH_METRIC;

}

int estimateconvert(char *target_md, void **result) {

	/* estimate the cost to convert from current method to
	   the target method target_me */
	
	void *lib;	
	int mt;


	void *est=(float *)(*result);

	void  *(*cvtfrom)();
		
	*result=NULL;

        if((mt=_getmethodid(target_md))==$1_NO_SUCH_METHOD) {
		return $1_NO_SUCH_METHOD;
	}
	else if(mt==_currentmethodid) {
		return $1_NO_SUCH_TRANSFORM;
	}

	lib=dlopen(_getmethodlib(mt),RTLD_LAZY);
	
	cvtfrom=dlsym(lib,_findcvtest(_currentmethodid,mt));

$$

	dlclose(lib);


	return $1_NO_SUCH_TRANSFORM;

}


int measurement(char *mc, void **result)  {

	int ms=_getmetricid(mc);

$$

	return $1_NO_SUCH_METRIC;

}

char * methodconversionquery(char *md) {

	/* return all possible target method for conversion to */

	static int mt;
	static int index;
	char *mname;

	if(md!=NULL) {
		mt=_getmethodid(md);
		index=0;
	}

	for(;index<$1_NOMETHOD;index++) {

		if(_methodtable[index].cvtfunc[mt].cvtfuncname!=NULL) {
			mname=_getmethodname(index);
			index++;
			return mname;
		}

	}
	return NULL;

	/*  pass md first time for the query,
	    pass NULL for the next, until return NULL */

        /* return supported method conversion */


}


int updateresult() {

	/* update decision tree using current performance result,
	   like a check point */




	$2 * _$3=($2 *)malloc(sizeof($2));
	measurement("$3",(void **)&_$3);


	nb_update(nb_getindex($1_NOPREDICATE,$4),_currentmethodid,(void *)_$3);

	nb_undecide(nb_getindex($1_NOPREDICATE,$4));

	nb_decide(nb_getindex($1_NOPREDICATE,$4),NB_SKIP_NULL);

	return $1_OK;

}

/* functions provided by lib writer */
$$

	
